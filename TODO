* Modern CSS (c.f. "6 patterns of CSS variables")
* FE condreq support
* Attempt to move httpapi structs to their resources
  - consider cohension around which endpoints are in which reource module
* Limit registrations per IP to forestall abuse
* Subcommand for cron to trigger DB cleanups (expired revokes)
* Disguise auth timing when no email

WTP parity:

F/E
* Events list view
  * Sorted table
  * Add
* Event edit
* Event view (game list)
  * Sorted table
  * Add game (BGG JS interface)
  * Want to play
  * Know rules
  * Personal notes
  * Who else? (is interested in this game)
* What should we play?
  * Other players
  * extra players

* Fork and strip for future projects
  * Rename semweb_api - "mattak" (b/c axum-mattak)

== Future work

* investigate elm-concurrent-task (enables JSON-LD and Biscuits in Elm)
* Client-side JSON-LD
  - flatten/expand responses
  - validate `expect`
  - in general decouple from exact B/E format
* Biscuit WASM port for Elm e.g.
  - check if my ip = requesting ip
  - check if time is in the next 60 seconds
* Sophisticated 409 handling in F/E for conditional updates (automatic 3-way merge)
* For the URITemplate/matchit "bridge"
  - consider adding the ability to "trade" '//' for a limit of 1 pre-path expression
* Derive macro for RouteTemplate enums - like:
Continuing to consider while building out the `routing` module. Would that be clearer?
Consideration also: would that be aligning Locator with RM variants.
```
#[derive(Copy, Clone, RouteTemplate)]
pub(crate) enum RouteMap {
    // adds arm to impl RouteTemplate
    // creates ProfileLocator struct with user_id: String field
    #[endpoint("/profile/{user_id}"]
    #[locator(ProfileLocator{String})]
    Profile,
    // adds arm, assumes you'll make the locator (likely EmptyLocator)
    #[endpoint("/")]
    Root,
    #[endpoint("/event_games/{event_id}/user/{user_id}")]
    #[locator(EventGamesLocator{u16, String})]
    EventGames
    // ...
}
```
  - datapoint: have seen errors that were confusing when URITemplate and Locator struct didn't align
    it would be great if that were impossible

* Consider further enforcing DB logic in types - DBIds are per-row-type, but currently
  Event<GameId> would work :/
* Middleware for conditional requests
  * If-Match & If-None-Match - check cache, and short circuit
  * If-Match & If-None-Match - check response/generated and empty bodies
* actually write a JSON-LD @context
* add JSON-LD tooling - at least validate our API
* multipart emails with HTML and images for password resets and whatnot

== Design Decisions

Progressive JSON-LD - use JSON-LD compatible fields as we go,
with the idea that we notionally have a @context.
Maybe someday we do this for real and build things out.
Minimize the amount of adjustment that takes.

pJSON-LD - use "id" and "type" etc
because "@id" requires extra serde macros to make work.
In our "notional" @context, we could `id: @id` to "fix" it.

Each B/E resource needs an IriTemplate field that describes how to get back there,
plus some SKOS Notations with the fields for it.
This lets the F/E embed the Notations into the browser address,
and then (e.g.) if reloaded/URL shared, fill in the template with the notations
to reload the data from the backend.
Open question: how to address user-context data?
(sharing the games for an event should show you your interests, not mine.)

JSON-LD _technically_ doesn't allow typemaps of scalars - IOW, where it would be nice to be able to say
notation: {
  event: <id>,
  user: <id>,
}
and have "event" and "user" be @contexted as datatype IRIs, JSON-LD doesn't expand that way.
*For the time being* we'll do that _anyway_ and if at some point we come in the validated fold,
we can adjust how we process SKOS notations as more verbose structures.

It's tempting, always to set up macros or something for what feel like
repetitive fields in the DB/HTTP DTOs. Some real wins with flattened sub-structs
in the DB, since the underlying tables are going imply some repetition,
making DB DTOs generic over Id types is a big win.
But! especially on the HTTP side,
generics and macros limit the flexibility of the API
by making seemingly related resources advance in lock-step.
In WTP we are seeing now a relationship between User and Profile
(that is: other folks at this event, and your own data.)
There's also relationships between every list/item pair.
These make it tempting to build general List/Item responses,
or #[derive(ListResponse)] or whatever.
However, every time I've considered that, it seems to me that every
remaining part of the similar-looking resources are a point of variability.
Breaking down elements that should be made automatic
from those that should allow human expression in their variation
is a key part of the design here, and needs to be considered carefully.

In general: the DB side of things
can be templated/automated to the degree it makes sense.
Overdoing it will be felt quickly, and the concern is completely about
making ergonomic queries of the database.

HTTP DTOs should err on the side of repetition.
Duplicating code now leaves room for variation later.
Interactions with the client are going to be the most painful to unpick.

Routing remains an area of interest.


HTTP DTOs: a delimma - do the DTOs get told `nested_at`, which feels a little out of scope,
or do we hand them their routing::Entries to work with.
Either could be made to work, but certainly lists would have to be given their item Entry as well....
and then any other relationship would have to be provided by the consumer,
ultimately coupling the evolution of a Resource to its consumers.
`nested_at`, on the other hand, is the only piece of information
that Resources (currently) require to determine routing for themselves,
which is huge.
It's possible, in future, that there would be more required,
in which case a RouteContext might be needed instead. Still: a single Ctx instead
of a bundle of `routing::Entry`s feels preferable - especially since
there's no theoretical limit on that bundle, up to the whole route map.
